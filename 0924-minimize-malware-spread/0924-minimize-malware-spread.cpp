class Solution {
public:
    int n;
    int parent[301];
    int rank[301];
    int findParent(int node){
        if(node==parent[node]){
            return node;
        }
        return parent[node]=findParent(parent[node]);
    }
    void unionn(int a,int b){
        int u=findParent(a);
        int v=findParent(b);
        if(rank[v]<rank[u]){
            parent[v]=u;
        }
        else if(rank[v]>rank[u]){
            parent[u]=v;
        }
        else{
            parent[u]=v;
            rank[v]++;
        }
    }
    int minMalwareSpread(vector<vector<int>>& graph, vector<int>& initial) {
        n=graph.size();
        for(int i=0;i<n;i++){
            parent[i]=i;
            rank[i]=0;
        }
        vector<int> group(n,0);//same components
        for(int i=0;i<n;i++){
            for(int j=i+1;j<n;j++){
                if(graph[i][j]){
                    unionn(i,j);
                }
            }
        }
        for(int i=0;i<n;i++)group[findParent(i)]++;
        int m=initial.size();
        vector<int> count(n,0);//infected counts of that parent
        for(int i=0;i<m;i++){
            count[findParent(initial[i])]++;
        }
        sort(initial.begin(),initial.end());
        //if more than 1 infections to all components, select smallest idx from any components...1
        //if only one infection, select larger size of components and it's index should be smallest
        int ans=initial[0]; // ....1
        int size=0;
        for(int i=0;i<m;i++){
            int x=findParent(initial[i]);
            if(count[x]==1 && size<group[x]){
                ans=initial[i];
                size=group[x];
            }
        }
        return ans;
    }
};


